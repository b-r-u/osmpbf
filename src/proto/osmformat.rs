// This file is generated by rust-protobuf 2.20.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `src/proto/osmformat.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_20_0;

#[derive(PartialEq,Clone,Default)]
pub struct HeaderBlock {
    // message fields
    pub bbox: ::protobuf::SingularPtrField<HeaderBBox>,
    pub required_features: ::protobuf::RepeatedField<::std::string::String>,
    pub optional_features: ::protobuf::RepeatedField<::std::string::String>,
    writingprogram: ::protobuf::SingularField<::std::string::String>,
    source: ::protobuf::SingularField<::std::string::String>,
    osmosis_replication_timestamp: ::std::option::Option<i64>,
    osmosis_replication_sequence_number: ::std::option::Option<i64>,
    osmosis_replication_base_url: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HeaderBlock {
    fn default() -> &'a HeaderBlock {
        <HeaderBlock as ::protobuf::Message>::default_instance()
    }
}

impl HeaderBlock {
    pub fn new() -> HeaderBlock {
        ::std::default::Default::default()
    }

    // optional .OSMPBF.HeaderBBox bbox = 1;


    pub fn get_bbox(&self) -> &HeaderBBox {
        self.bbox.as_ref().unwrap_or_else(|| <HeaderBBox as ::protobuf::Message>::default_instance())
    }
    pub fn clear_bbox(&mut self) {
        self.bbox.clear();
    }

    pub fn has_bbox(&self) -> bool {
        self.bbox.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bbox(&mut self, v: HeaderBBox) {
        self.bbox = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bbox(&mut self) -> &mut HeaderBBox {
        if self.bbox.is_none() {
            self.bbox.set_default();
        }
        self.bbox.as_mut().unwrap()
    }

    // Take field
    pub fn take_bbox(&mut self) -> HeaderBBox {
        self.bbox.take().unwrap_or_else(|| HeaderBBox::new())
    }

    // repeated string required_features = 4;


    pub fn get_required_features(&self) -> &[::std::string::String] {
        &self.required_features
    }
    pub fn clear_required_features(&mut self) {
        self.required_features.clear();
    }

    // Param is passed by value, moved
    pub fn set_required_features(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.required_features = v;
    }

    // Mutable pointer to the field.
    pub fn mut_required_features(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.required_features
    }

    // Take field
    pub fn take_required_features(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.required_features, ::protobuf::RepeatedField::new())
    }

    // repeated string optional_features = 5;


    pub fn get_optional_features(&self) -> &[::std::string::String] {
        &self.optional_features
    }
    pub fn clear_optional_features(&mut self) {
        self.optional_features.clear();
    }

    // Param is passed by value, moved
    pub fn set_optional_features(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.optional_features = v;
    }

    // Mutable pointer to the field.
    pub fn mut_optional_features(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.optional_features
    }

    // Take field
    pub fn take_optional_features(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.optional_features, ::protobuf::RepeatedField::new())
    }

    // optional string writingprogram = 16;


    pub fn get_writingprogram(&self) -> &str {
        match self.writingprogram.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_writingprogram(&mut self) {
        self.writingprogram.clear();
    }

    pub fn has_writingprogram(&self) -> bool {
        self.writingprogram.is_some()
    }

    // Param is passed by value, moved
    pub fn set_writingprogram(&mut self, v: ::std::string::String) {
        self.writingprogram = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_writingprogram(&mut self) -> &mut ::std::string::String {
        if self.writingprogram.is_none() {
            self.writingprogram.set_default();
        }
        self.writingprogram.as_mut().unwrap()
    }

    // Take field
    pub fn take_writingprogram(&mut self) -> ::std::string::String {
        self.writingprogram.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string source = 17;


    pub fn get_source(&self) -> &str {
        match self.source.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: ::std::string::String) {
        self.source = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut ::std::string::String {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> ::std::string::String {
        self.source.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 osmosis_replication_timestamp = 32;


    pub fn get_osmosis_replication_timestamp(&self) -> i64 {
        self.osmosis_replication_timestamp.unwrap_or(0)
    }
    pub fn clear_osmosis_replication_timestamp(&mut self) {
        self.osmosis_replication_timestamp = ::std::option::Option::None;
    }

    pub fn has_osmosis_replication_timestamp(&self) -> bool {
        self.osmosis_replication_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_osmosis_replication_timestamp(&mut self, v: i64) {
        self.osmosis_replication_timestamp = ::std::option::Option::Some(v);
    }

    // optional int64 osmosis_replication_sequence_number = 33;


    pub fn get_osmosis_replication_sequence_number(&self) -> i64 {
        self.osmosis_replication_sequence_number.unwrap_or(0)
    }
    pub fn clear_osmosis_replication_sequence_number(&mut self) {
        self.osmosis_replication_sequence_number = ::std::option::Option::None;
    }

    pub fn has_osmosis_replication_sequence_number(&self) -> bool {
        self.osmosis_replication_sequence_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_osmosis_replication_sequence_number(&mut self, v: i64) {
        self.osmosis_replication_sequence_number = ::std::option::Option::Some(v);
    }

    // optional string osmosis_replication_base_url = 34;


    pub fn get_osmosis_replication_base_url(&self) -> &str {
        match self.osmosis_replication_base_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_osmosis_replication_base_url(&mut self) {
        self.osmosis_replication_base_url.clear();
    }

    pub fn has_osmosis_replication_base_url(&self) -> bool {
        self.osmosis_replication_base_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_osmosis_replication_base_url(&mut self, v: ::std::string::String) {
        self.osmosis_replication_base_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_osmosis_replication_base_url(&mut self) -> &mut ::std::string::String {
        if self.osmosis_replication_base_url.is_none() {
            self.osmosis_replication_base_url.set_default();
        }
        self.osmosis_replication_base_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_osmosis_replication_base_url(&mut self) -> ::std::string::String {
        self.osmosis_replication_base_url.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for HeaderBlock {
    fn is_initialized(&self) -> bool {
        for v in &self.bbox {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bbox)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.required_features)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.optional_features)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.writingprogram)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.source)?;
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.osmosis_replication_timestamp = ::std::option::Option::Some(tmp);
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.osmosis_replication_sequence_number = ::std::option::Option::Some(tmp);
                },
                34 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.osmosis_replication_base_url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.bbox.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.required_features {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.optional_features {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if let Some(ref v) = self.writingprogram.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(ref v) = self.source.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(v) = self.osmosis_replication_timestamp {
            my_size += ::protobuf::rt::value_size(32, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.osmosis_replication_sequence_number {
            my_size += ::protobuf::rt::value_size(33, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.osmosis_replication_base_url.as_ref() {
            my_size += ::protobuf::rt::string_size(34, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.bbox.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.required_features {
            os.write_string(4, &v)?;
        };
        for v in &self.optional_features {
            os.write_string(5, &v)?;
        };
        if let Some(ref v) = self.writingprogram.as_ref() {
            os.write_string(16, &v)?;
        }
        if let Some(ref v) = self.source.as_ref() {
            os.write_string(17, &v)?;
        }
        if let Some(v) = self.osmosis_replication_timestamp {
            os.write_int64(32, v)?;
        }
        if let Some(v) = self.osmosis_replication_sequence_number {
            os.write_int64(33, v)?;
        }
        if let Some(ref v) = self.osmosis_replication_base_url.as_ref() {
            os.write_string(34, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HeaderBlock {
        HeaderBlock::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HeaderBBox>>(
                "bbox",
                |m: &HeaderBlock| { &m.bbox },
                |m: &mut HeaderBlock| { &mut m.bbox },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "required_features",
                |m: &HeaderBlock| { &m.required_features },
                |m: &mut HeaderBlock| { &mut m.required_features },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "optional_features",
                |m: &HeaderBlock| { &m.optional_features },
                |m: &mut HeaderBlock| { &mut m.optional_features },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "writingprogram",
                |m: &HeaderBlock| { &m.writingprogram },
                |m: &mut HeaderBlock| { &mut m.writingprogram },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "source",
                |m: &HeaderBlock| { &m.source },
                |m: &mut HeaderBlock| { &mut m.source },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "osmosis_replication_timestamp",
                |m: &HeaderBlock| { &m.osmosis_replication_timestamp },
                |m: &mut HeaderBlock| { &mut m.osmosis_replication_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "osmosis_replication_sequence_number",
                |m: &HeaderBlock| { &m.osmosis_replication_sequence_number },
                |m: &mut HeaderBlock| { &mut m.osmosis_replication_sequence_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "osmosis_replication_base_url",
                |m: &HeaderBlock| { &m.osmosis_replication_base_url },
                |m: &mut HeaderBlock| { &mut m.osmosis_replication_base_url },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HeaderBlock>(
                "HeaderBlock",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HeaderBlock {
        static instance: ::protobuf::rt::LazyV2<HeaderBlock> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HeaderBlock::new)
    }
}

impl ::protobuf::Clear for HeaderBlock {
    fn clear(&mut self) {
        self.bbox.clear();
        self.required_features.clear();
        self.optional_features.clear();
        self.writingprogram.clear();
        self.source.clear();
        self.osmosis_replication_timestamp = ::std::option::Option::None;
        self.osmosis_replication_sequence_number = ::std::option::Option::None;
        self.osmosis_replication_base_url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HeaderBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HeaderBlock {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HeaderBBox {
    // message fields
    left: ::std::option::Option<i64>,
    right: ::std::option::Option<i64>,
    top: ::std::option::Option<i64>,
    bottom: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HeaderBBox {
    fn default() -> &'a HeaderBBox {
        <HeaderBBox as ::protobuf::Message>::default_instance()
    }
}

impl HeaderBBox {
    pub fn new() -> HeaderBBox {
        ::std::default::Default::default()
    }

    // required sint64 left = 1;


    pub fn get_left(&self) -> i64 {
        self.left.unwrap_or(0)
    }
    pub fn clear_left(&mut self) {
        self.left = ::std::option::Option::None;
    }

    pub fn has_left(&self) -> bool {
        self.left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_left(&mut self, v: i64) {
        self.left = ::std::option::Option::Some(v);
    }

    // required sint64 right = 2;


    pub fn get_right(&self) -> i64 {
        self.right.unwrap_or(0)
    }
    pub fn clear_right(&mut self) {
        self.right = ::std::option::Option::None;
    }

    pub fn has_right(&self) -> bool {
        self.right.is_some()
    }

    // Param is passed by value, moved
    pub fn set_right(&mut self, v: i64) {
        self.right = ::std::option::Option::Some(v);
    }

    // required sint64 top = 3;


    pub fn get_top(&self) -> i64 {
        self.top.unwrap_or(0)
    }
    pub fn clear_top(&mut self) {
        self.top = ::std::option::Option::None;
    }

    pub fn has_top(&self) -> bool {
        self.top.is_some()
    }

    // Param is passed by value, moved
    pub fn set_top(&mut self, v: i64) {
        self.top = ::std::option::Option::Some(v);
    }

    // required sint64 bottom = 4;


    pub fn get_bottom(&self) -> i64 {
        self.bottom.unwrap_or(0)
    }
    pub fn clear_bottom(&mut self) {
        self.bottom = ::std::option::Option::None;
    }

    pub fn has_bottom(&self) -> bool {
        self.bottom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bottom(&mut self, v: i64) {
        self.bottom = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for HeaderBBox {
    fn is_initialized(&self) -> bool {
        if self.left.is_none() {
            return false;
        }
        if self.right.is_none() {
            return false;
        }
        if self.top.is_none() {
            return false;
        }
        if self.bottom.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.left = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.right = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.top = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.bottom = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.left {
            my_size += ::protobuf::rt::value_varint_zigzag_size(1, v);
        }
        if let Some(v) = self.right {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, v);
        }
        if let Some(v) = self.top {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, v);
        }
        if let Some(v) = self.bottom {
            my_size += ::protobuf::rt::value_varint_zigzag_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.left {
            os.write_sint64(1, v)?;
        }
        if let Some(v) = self.right {
            os.write_sint64(2, v)?;
        }
        if let Some(v) = self.top {
            os.write_sint64(3, v)?;
        }
        if let Some(v) = self.bottom {
            os.write_sint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HeaderBBox {
        HeaderBBox::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "left",
                |m: &HeaderBBox| { &m.left },
                |m: &mut HeaderBBox| { &mut m.left },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "right",
                |m: &HeaderBBox| { &m.right },
                |m: &mut HeaderBBox| { &mut m.right },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "top",
                |m: &HeaderBBox| { &m.top },
                |m: &mut HeaderBBox| { &mut m.top },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "bottom",
                |m: &HeaderBBox| { &m.bottom },
                |m: &mut HeaderBBox| { &mut m.bottom },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HeaderBBox>(
                "HeaderBBox",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HeaderBBox {
        static instance: ::protobuf::rt::LazyV2<HeaderBBox> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HeaderBBox::new)
    }
}

impl ::protobuf::Clear for HeaderBBox {
    fn clear(&mut self) {
        self.left = ::std::option::Option::None;
        self.right = ::std::option::Option::None;
        self.top = ::std::option::Option::None;
        self.bottom = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HeaderBBox {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HeaderBBox {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PrimitiveBlock {
    // message fields
    pub stringtable: ::protobuf::SingularPtrField<StringTable>,
    pub primitivegroup: ::protobuf::RepeatedField<PrimitiveGroup>,
    granularity: ::std::option::Option<i32>,
    lat_offset: ::std::option::Option<i64>,
    lon_offset: ::std::option::Option<i64>,
    date_granularity: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PrimitiveBlock {
    fn default() -> &'a PrimitiveBlock {
        <PrimitiveBlock as ::protobuf::Message>::default_instance()
    }
}

impl PrimitiveBlock {
    pub fn new() -> PrimitiveBlock {
        ::std::default::Default::default()
    }

    // required .OSMPBF.StringTable stringtable = 1;


    pub fn get_stringtable(&self) -> &StringTable {
        self.stringtable.as_ref().unwrap_or_else(|| <StringTable as ::protobuf::Message>::default_instance())
    }
    pub fn clear_stringtable(&mut self) {
        self.stringtable.clear();
    }

    pub fn has_stringtable(&self) -> bool {
        self.stringtable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stringtable(&mut self, v: StringTable) {
        self.stringtable = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stringtable(&mut self) -> &mut StringTable {
        if self.stringtable.is_none() {
            self.stringtable.set_default();
        }
        self.stringtable.as_mut().unwrap()
    }

    // Take field
    pub fn take_stringtable(&mut self) -> StringTable {
        self.stringtable.take().unwrap_or_else(|| StringTable::new())
    }

    // repeated .OSMPBF.PrimitiveGroup primitivegroup = 2;


    pub fn get_primitivegroup(&self) -> &[PrimitiveGroup] {
        &self.primitivegroup
    }
    pub fn clear_primitivegroup(&mut self) {
        self.primitivegroup.clear();
    }

    // Param is passed by value, moved
    pub fn set_primitivegroup(&mut self, v: ::protobuf::RepeatedField<PrimitiveGroup>) {
        self.primitivegroup = v;
    }

    // Mutable pointer to the field.
    pub fn mut_primitivegroup(&mut self) -> &mut ::protobuf::RepeatedField<PrimitiveGroup> {
        &mut self.primitivegroup
    }

    // Take field
    pub fn take_primitivegroup(&mut self) -> ::protobuf::RepeatedField<PrimitiveGroup> {
        ::std::mem::replace(&mut self.primitivegroup, ::protobuf::RepeatedField::new())
    }

    // optional int32 granularity = 17;


    pub fn get_granularity(&self) -> i32 {
        self.granularity.unwrap_or(100i32)
    }
    pub fn clear_granularity(&mut self) {
        self.granularity = ::std::option::Option::None;
    }

    pub fn has_granularity(&self) -> bool {
        self.granularity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_granularity(&mut self, v: i32) {
        self.granularity = ::std::option::Option::Some(v);
    }

    // optional int64 lat_offset = 19;


    pub fn get_lat_offset(&self) -> i64 {
        self.lat_offset.unwrap_or(0i64)
    }
    pub fn clear_lat_offset(&mut self) {
        self.lat_offset = ::std::option::Option::None;
    }

    pub fn has_lat_offset(&self) -> bool {
        self.lat_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lat_offset(&mut self, v: i64) {
        self.lat_offset = ::std::option::Option::Some(v);
    }

    // optional int64 lon_offset = 20;


    pub fn get_lon_offset(&self) -> i64 {
        self.lon_offset.unwrap_or(0i64)
    }
    pub fn clear_lon_offset(&mut self) {
        self.lon_offset = ::std::option::Option::None;
    }

    pub fn has_lon_offset(&self) -> bool {
        self.lon_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lon_offset(&mut self, v: i64) {
        self.lon_offset = ::std::option::Option::Some(v);
    }

    // optional int32 date_granularity = 18;


    pub fn get_date_granularity(&self) -> i32 {
        self.date_granularity.unwrap_or(1000i32)
    }
    pub fn clear_date_granularity(&mut self) {
        self.date_granularity = ::std::option::Option::None;
    }

    pub fn has_date_granularity(&self) -> bool {
        self.date_granularity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date_granularity(&mut self, v: i32) {
        self.date_granularity = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PrimitiveBlock {
    fn is_initialized(&self) -> bool {
        if self.stringtable.is_none() {
            return false;
        }
        for v in &self.stringtable {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.primitivegroup {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stringtable)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.primitivegroup)?;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.granularity = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.lat_offset = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.lon_offset = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.date_granularity = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.stringtable.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.primitivegroup {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.granularity {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lat_offset {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lon_offset {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.date_granularity {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.stringtable.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.primitivegroup {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.granularity {
            os.write_int32(17, v)?;
        }
        if let Some(v) = self.lat_offset {
            os.write_int64(19, v)?;
        }
        if let Some(v) = self.lon_offset {
            os.write_int64(20, v)?;
        }
        if let Some(v) = self.date_granularity {
            os.write_int32(18, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PrimitiveBlock {
        PrimitiveBlock::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StringTable>>(
                "stringtable",
                |m: &PrimitiveBlock| { &m.stringtable },
                |m: &mut PrimitiveBlock| { &mut m.stringtable },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PrimitiveGroup>>(
                "primitivegroup",
                |m: &PrimitiveBlock| { &m.primitivegroup },
                |m: &mut PrimitiveBlock| { &mut m.primitivegroup },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "granularity",
                |m: &PrimitiveBlock| { &m.granularity },
                |m: &mut PrimitiveBlock| { &mut m.granularity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "lat_offset",
                |m: &PrimitiveBlock| { &m.lat_offset },
                |m: &mut PrimitiveBlock| { &mut m.lat_offset },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "lon_offset",
                |m: &PrimitiveBlock| { &m.lon_offset },
                |m: &mut PrimitiveBlock| { &mut m.lon_offset },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "date_granularity",
                |m: &PrimitiveBlock| { &m.date_granularity },
                |m: &mut PrimitiveBlock| { &mut m.date_granularity },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PrimitiveBlock>(
                "PrimitiveBlock",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PrimitiveBlock {
        static instance: ::protobuf::rt::LazyV2<PrimitiveBlock> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PrimitiveBlock::new)
    }
}

impl ::protobuf::Clear for PrimitiveBlock {
    fn clear(&mut self) {
        self.stringtable.clear();
        self.primitivegroup.clear();
        self.granularity = ::std::option::Option::None;
        self.lat_offset = ::std::option::Option::None;
        self.lon_offset = ::std::option::Option::None;
        self.date_granularity = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PrimitiveBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PrimitiveBlock {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PrimitiveGroup {
    // message fields
    pub nodes: ::protobuf::RepeatedField<Node>,
    pub dense: ::protobuf::SingularPtrField<DenseNodes>,
    pub ways: ::protobuf::RepeatedField<Way>,
    pub relations: ::protobuf::RepeatedField<Relation>,
    pub changesets: ::protobuf::RepeatedField<ChangeSet>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PrimitiveGroup {
    fn default() -> &'a PrimitiveGroup {
        <PrimitiveGroup as ::protobuf::Message>::default_instance()
    }
}

impl PrimitiveGroup {
    pub fn new() -> PrimitiveGroup {
        ::std::default::Default::default()
    }

    // repeated .OSMPBF.Node nodes = 1;


    pub fn get_nodes(&self) -> &[Node] {
        &self.nodes
    }
    pub fn clear_nodes(&mut self) {
        self.nodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodes(&mut self, v: ::protobuf::RepeatedField<Node>) {
        self.nodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodes(&mut self) -> &mut ::protobuf::RepeatedField<Node> {
        &mut self.nodes
    }

    // Take field
    pub fn take_nodes(&mut self) -> ::protobuf::RepeatedField<Node> {
        ::std::mem::replace(&mut self.nodes, ::protobuf::RepeatedField::new())
    }

    // optional .OSMPBF.DenseNodes dense = 2;


    pub fn get_dense(&self) -> &DenseNodes {
        self.dense.as_ref().unwrap_or_else(|| <DenseNodes as ::protobuf::Message>::default_instance())
    }
    pub fn clear_dense(&mut self) {
        self.dense.clear();
    }

    pub fn has_dense(&self) -> bool {
        self.dense.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dense(&mut self, v: DenseNodes) {
        self.dense = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dense(&mut self) -> &mut DenseNodes {
        if self.dense.is_none() {
            self.dense.set_default();
        }
        self.dense.as_mut().unwrap()
    }

    // Take field
    pub fn take_dense(&mut self) -> DenseNodes {
        self.dense.take().unwrap_or_else(|| DenseNodes::new())
    }

    // repeated .OSMPBF.Way ways = 3;


    pub fn get_ways(&self) -> &[Way] {
        &self.ways
    }
    pub fn clear_ways(&mut self) {
        self.ways.clear();
    }

    // Param is passed by value, moved
    pub fn set_ways(&mut self, v: ::protobuf::RepeatedField<Way>) {
        self.ways = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ways(&mut self) -> &mut ::protobuf::RepeatedField<Way> {
        &mut self.ways
    }

    // Take field
    pub fn take_ways(&mut self) -> ::protobuf::RepeatedField<Way> {
        ::std::mem::replace(&mut self.ways, ::protobuf::RepeatedField::new())
    }

    // repeated .OSMPBF.Relation relations = 4;


    pub fn get_relations(&self) -> &[Relation] {
        &self.relations
    }
    pub fn clear_relations(&mut self) {
        self.relations.clear();
    }

    // Param is passed by value, moved
    pub fn set_relations(&mut self, v: ::protobuf::RepeatedField<Relation>) {
        self.relations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_relations(&mut self) -> &mut ::protobuf::RepeatedField<Relation> {
        &mut self.relations
    }

    // Take field
    pub fn take_relations(&mut self) -> ::protobuf::RepeatedField<Relation> {
        ::std::mem::replace(&mut self.relations, ::protobuf::RepeatedField::new())
    }

    // repeated .OSMPBF.ChangeSet changesets = 5;


    pub fn get_changesets(&self) -> &[ChangeSet] {
        &self.changesets
    }
    pub fn clear_changesets(&mut self) {
        self.changesets.clear();
    }

    // Param is passed by value, moved
    pub fn set_changesets(&mut self, v: ::protobuf::RepeatedField<ChangeSet>) {
        self.changesets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_changesets(&mut self) -> &mut ::protobuf::RepeatedField<ChangeSet> {
        &mut self.changesets
    }

    // Take field
    pub fn take_changesets(&mut self) -> ::protobuf::RepeatedField<ChangeSet> {
        ::std::mem::replace(&mut self.changesets, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PrimitiveGroup {
    fn is_initialized(&self) -> bool {
        for v in &self.nodes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dense {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ways {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.relations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.changesets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.nodes)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dense)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ways)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.relations)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.changesets)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.dense.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.ways {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.relations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.changesets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.nodes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.dense.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ways {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.relations {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.changesets {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PrimitiveGroup {
        PrimitiveGroup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Node>>(
                "nodes",
                |m: &PrimitiveGroup| { &m.nodes },
                |m: &mut PrimitiveGroup| { &mut m.nodes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DenseNodes>>(
                "dense",
                |m: &PrimitiveGroup| { &m.dense },
                |m: &mut PrimitiveGroup| { &mut m.dense },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Way>>(
                "ways",
                |m: &PrimitiveGroup| { &m.ways },
                |m: &mut PrimitiveGroup| { &mut m.ways },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Relation>>(
                "relations",
                |m: &PrimitiveGroup| { &m.relations },
                |m: &mut PrimitiveGroup| { &mut m.relations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChangeSet>>(
                "changesets",
                |m: &PrimitiveGroup| { &m.changesets },
                |m: &mut PrimitiveGroup| { &mut m.changesets },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PrimitiveGroup>(
                "PrimitiveGroup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PrimitiveGroup {
        static instance: ::protobuf::rt::LazyV2<PrimitiveGroup> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PrimitiveGroup::new)
    }
}

impl ::protobuf::Clear for PrimitiveGroup {
    fn clear(&mut self) {
        self.nodes.clear();
        self.dense.clear();
        self.ways.clear();
        self.relations.clear();
        self.changesets.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PrimitiveGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PrimitiveGroup {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StringTable {
    // message fields
    pub s: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StringTable {
    fn default() -> &'a StringTable {
        <StringTable as ::protobuf::Message>::default_instance()
    }
}

impl StringTable {
    pub fn new() -> StringTable {
        ::std::default::Default::default()
    }

    // repeated bytes s = 1;


    pub fn get_s(&self) -> &[::std::vec::Vec<u8>] {
        &self.s
    }
    pub fn clear_s(&mut self) {
        self.s.clear();
    }

    // Param is passed by value, moved
    pub fn set_s(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.s = v;
    }

    // Mutable pointer to the field.
    pub fn mut_s(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.s
    }

    // Take field
    pub fn take_s(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.s, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StringTable {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.s)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.s {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.s {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StringTable {
        StringTable::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "s",
                |m: &StringTable| { &m.s },
                |m: &mut StringTable| { &mut m.s },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StringTable>(
                "StringTable",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StringTable {
        static instance: ::protobuf::rt::LazyV2<StringTable> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StringTable::new)
    }
}

impl ::protobuf::Clear for StringTable {
    fn clear(&mut self) {
        self.s.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StringTable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StringTable {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Info {
    // message fields
    version: ::std::option::Option<i32>,
    timestamp: ::std::option::Option<i64>,
    changeset: ::std::option::Option<i64>,
    uid: ::std::option::Option<i32>,
    user_sid: ::std::option::Option<u32>,
    visible: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Info {
    fn default() -> &'a Info {
        <Info as ::protobuf::Message>::default_instance()
    }
}

impl Info {
    pub fn new() -> Info {
        ::std::default::Default::default()
    }

    // optional int32 version = 1;


    pub fn get_version(&self) -> i32 {
        self.version.unwrap_or(-1i32)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional int64 timestamp = 2;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional int64 changeset = 3;


    pub fn get_changeset(&self) -> i64 {
        self.changeset.unwrap_or(0)
    }
    pub fn clear_changeset(&mut self) {
        self.changeset = ::std::option::Option::None;
    }

    pub fn has_changeset(&self) -> bool {
        self.changeset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_changeset(&mut self, v: i64) {
        self.changeset = ::std::option::Option::Some(v);
    }

    // optional int32 uid = 4;


    pub fn get_uid(&self) -> i32 {
        self.uid.unwrap_or(0)
    }
    pub fn clear_uid(&mut self) {
        self.uid = ::std::option::Option::None;
    }

    pub fn has_uid(&self) -> bool {
        self.uid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: i32) {
        self.uid = ::std::option::Option::Some(v);
    }

    // optional uint32 user_sid = 5;


    pub fn get_user_sid(&self) -> u32 {
        self.user_sid.unwrap_or(0)
    }
    pub fn clear_user_sid(&mut self) {
        self.user_sid = ::std::option::Option::None;
    }

    pub fn has_user_sid(&self) -> bool {
        self.user_sid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_sid(&mut self, v: u32) {
        self.user_sid = ::std::option::Option::Some(v);
    }

    // optional bool visible = 6;


    pub fn get_visible(&self) -> bool {
        self.visible.unwrap_or(false)
    }
    pub fn clear_visible(&mut self) {
        self.visible = ::std::option::Option::None;
    }

    pub fn has_visible(&self) -> bool {
        self.visible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visible(&mut self, v: bool) {
        self.visible = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Info {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.changeset = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.uid = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.user_sid = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.visible = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.changeset {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.uid {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.user_sid {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.visible {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.changeset {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.uid {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.user_sid {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.visible {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Info {
        Info::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "version",
                |m: &Info| { &m.version },
                |m: &mut Info| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timestamp",
                |m: &Info| { &m.timestamp },
                |m: &mut Info| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "changeset",
                |m: &Info| { &m.changeset },
                |m: &mut Info| { &mut m.changeset },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "uid",
                |m: &Info| { &m.uid },
                |m: &mut Info| { &mut m.uid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "user_sid",
                |m: &Info| { &m.user_sid },
                |m: &mut Info| { &mut m.user_sid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "visible",
                |m: &Info| { &m.visible },
                |m: &mut Info| { &mut m.visible },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Info>(
                "Info",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Info {
        static instance: ::protobuf::rt::LazyV2<Info> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Info::new)
    }
}

impl ::protobuf::Clear for Info {
    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.changeset = ::std::option::Option::None;
        self.uid = ::std::option::Option::None;
        self.user_sid = ::std::option::Option::None;
        self.visible = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Info {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Info {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DenseInfo {
    // message fields
    pub version: ::std::vec::Vec<i32>,
    pub timestamp: ::std::vec::Vec<i64>,
    pub changeset: ::std::vec::Vec<i64>,
    pub uid: ::std::vec::Vec<i32>,
    pub user_sid: ::std::vec::Vec<i32>,
    pub visible: ::std::vec::Vec<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DenseInfo {
    fn default() -> &'a DenseInfo {
        <DenseInfo as ::protobuf::Message>::default_instance()
    }
}

impl DenseInfo {
    pub fn new() -> DenseInfo {
        ::std::default::Default::default()
    }

    // repeated int32 version = 1;


    pub fn get_version(&self) -> &[i32] {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::vec::Vec<i32>) {
        self.version = v;
    }

    // Mutable pointer to the field.
    pub fn mut_version(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.version, ::std::vec::Vec::new())
    }

    // repeated sint64 timestamp = 2;


    pub fn get_timestamp(&self) -> &[i64] {
        &self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp.clear();
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: ::std::vec::Vec<i64>) {
        self.timestamp = v;
    }

    // Mutable pointer to the field.
    pub fn mut_timestamp(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.timestamp
    }

    // Take field
    pub fn take_timestamp(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.timestamp, ::std::vec::Vec::new())
    }

    // repeated sint64 changeset = 3;


    pub fn get_changeset(&self) -> &[i64] {
        &self.changeset
    }
    pub fn clear_changeset(&mut self) {
        self.changeset.clear();
    }

    // Param is passed by value, moved
    pub fn set_changeset(&mut self, v: ::std::vec::Vec<i64>) {
        self.changeset = v;
    }

    // Mutable pointer to the field.
    pub fn mut_changeset(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.changeset
    }

    // Take field
    pub fn take_changeset(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.changeset, ::std::vec::Vec::new())
    }

    // repeated sint32 uid = 4;


    pub fn get_uid(&self) -> &[i32] {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::vec::Vec<i32>) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    pub fn mut_uid(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.uid, ::std::vec::Vec::new())
    }

    // repeated sint32 user_sid = 5;


    pub fn get_user_sid(&self) -> &[i32] {
        &self.user_sid
    }
    pub fn clear_user_sid(&mut self) {
        self.user_sid.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_sid(&mut self, v: ::std::vec::Vec<i32>) {
        self.user_sid = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_sid(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.user_sid
    }

    // Take field
    pub fn take_user_sid(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.user_sid, ::std::vec::Vec::new())
    }

    // repeated bool visible = 6;


    pub fn get_visible(&self) -> &[bool] {
        &self.visible
    }
    pub fn clear_visible(&mut self) {
        self.visible.clear();
    }

    // Param is passed by value, moved
    pub fn set_visible(&mut self, v: ::std::vec::Vec<bool>) {
        self.visible = v;
    }

    // Mutable pointer to the field.
    pub fn mut_visible(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.visible
    }

    // Take field
    pub fn take_visible(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.visible, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DenseInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.version)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_sint64_into(wire_type, is, &mut self.timestamp)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_sint64_into(wire_type, is, &mut self.changeset)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_sint32_into(wire_type, is, &mut self.uid)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_sint32_into(wire_type, is, &mut self.user_sid)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.visible)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(1, &self.version);
        }
        if !self.timestamp.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_zigzag_size(2, &self.timestamp);
        }
        if !self.changeset.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_zigzag_size(3, &self.changeset);
        }
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_zigzag_size(4, &self.uid);
        }
        if !self.user_sid.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_zigzag_size(5, &self.user_sid);
        }
        if !self.visible.is_empty() {
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size((self.visible.len() * 1) as u32) + (self.visible.len() * 1) as u32;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.version.is_empty() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.version))?;
            for v in &self.version {
                os.write_int32_no_tag(*v)?;
            };
        }
        if !self.timestamp.is_empty() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_zigzag_data_size(&self.timestamp))?;
            for v in &self.timestamp {
                os.write_sint64_no_tag(*v)?;
            };
        }
        if !self.changeset.is_empty() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_zigzag_data_size(&self.changeset))?;
            for v in &self.changeset {
                os.write_sint64_no_tag(*v)?;
            };
        }
        if !self.uid.is_empty() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_zigzag_data_size(&self.uid))?;
            for v in &self.uid {
                os.write_sint32_no_tag(*v)?;
            };
        }
        if !self.user_sid.is_empty() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_zigzag_data_size(&self.user_sid))?;
            for v in &self.user_sid {
                os.write_sint32_no_tag(*v)?;
            };
        }
        if !self.visible.is_empty() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.visible.len() * 1) as u32)?;
            for v in &self.visible {
                os.write_bool_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DenseInfo {
        DenseInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "version",
                |m: &DenseInfo| { &m.version },
                |m: &mut DenseInfo| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "timestamp",
                |m: &DenseInfo| { &m.timestamp },
                |m: &mut DenseInfo| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "changeset",
                |m: &DenseInfo| { &m.changeset },
                |m: &mut DenseInfo| { &mut m.changeset },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                "uid",
                |m: &DenseInfo| { &m.uid },
                |m: &mut DenseInfo| { &mut m.uid },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                "user_sid",
                |m: &DenseInfo| { &m.user_sid },
                |m: &mut DenseInfo| { &mut m.user_sid },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "visible",
                |m: &DenseInfo| { &m.visible },
                |m: &mut DenseInfo| { &mut m.visible },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DenseInfo>(
                "DenseInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DenseInfo {
        static instance: ::protobuf::rt::LazyV2<DenseInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DenseInfo::new)
    }
}

impl ::protobuf::Clear for DenseInfo {
    fn clear(&mut self) {
        self.version.clear();
        self.timestamp.clear();
        self.changeset.clear();
        self.uid.clear();
        self.user_sid.clear();
        self.visible.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DenseInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DenseInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChangeSet {
    // message fields
    id: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChangeSet {
    fn default() -> &'a ChangeSet {
        <ChangeSet as ::protobuf::Message>::default_instance()
    }
}

impl ChangeSet {
    pub fn new() -> ChangeSet {
        ::std::default::Default::default()
    }

    // required int64 id = 1;


    pub fn get_id(&self) -> i64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ChangeSet {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChangeSet {
        ChangeSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "id",
                |m: &ChangeSet| { &m.id },
                |m: &mut ChangeSet| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChangeSet>(
                "ChangeSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChangeSet {
        static instance: ::protobuf::rt::LazyV2<ChangeSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChangeSet::new)
    }
}

impl ::protobuf::Clear for ChangeSet {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChangeSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChangeSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Node {
    // message fields
    id: ::std::option::Option<i64>,
    pub keys: ::std::vec::Vec<u32>,
    pub vals: ::std::vec::Vec<u32>,
    pub info: ::protobuf::SingularPtrField<Info>,
    lat: ::std::option::Option<i64>,
    lon: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Node {
    fn default() -> &'a Node {
        <Node as ::protobuf::Message>::default_instance()
    }
}

impl Node {
    pub fn new() -> Node {
        ::std::default::Default::default()
    }

    // required sint64 id = 1;


    pub fn get_id(&self) -> i64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }

    // repeated uint32 keys = 2;


    pub fn get_keys(&self) -> &[u32] {
        &self.keys
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::std::vec::Vec<u32>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.keys
    }

    // Take field
    pub fn take_keys(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.keys, ::std::vec::Vec::new())
    }

    // repeated uint32 vals = 3;


    pub fn get_vals(&self) -> &[u32] {
        &self.vals
    }
    pub fn clear_vals(&mut self) {
        self.vals.clear();
    }

    // Param is passed by value, moved
    pub fn set_vals(&mut self, v: ::std::vec::Vec<u32>) {
        self.vals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vals(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.vals
    }

    // Take field
    pub fn take_vals(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.vals, ::std::vec::Vec::new())
    }

    // optional .OSMPBF.Info info = 4;


    pub fn get_info(&self) -> &Info {
        self.info.as_ref().unwrap_or_else(|| <Info as ::protobuf::Message>::default_instance())
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: Info) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut Info {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> Info {
        self.info.take().unwrap_or_else(|| Info::new())
    }

    // required sint64 lat = 8;


    pub fn get_lat(&self) -> i64 {
        self.lat.unwrap_or(0)
    }
    pub fn clear_lat(&mut self) {
        self.lat = ::std::option::Option::None;
    }

    pub fn has_lat(&self) -> bool {
        self.lat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lat(&mut self, v: i64) {
        self.lat = ::std::option::Option::Some(v);
    }

    // required sint64 lon = 9;


    pub fn get_lon(&self) -> i64 {
        self.lon.unwrap_or(0)
    }
    pub fn clear_lon(&mut self) {
        self.lon = ::std::option::Option::None;
    }

    pub fn has_lon(&self) -> bool {
        self.lon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lon(&mut self, v: i64) {
        self.lon = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Node {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.lat.is_none() {
            return false;
        }
        if self.lon.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.keys)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.vals)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.lat = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.lon = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_varint_zigzag_size(1, v);
        }
        if !self.keys.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(2, &self.keys);
        }
        if !self.vals.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(3, &self.vals);
        }
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.lat {
            my_size += ::protobuf::rt::value_varint_zigzag_size(8, v);
        }
        if let Some(v) = self.lon {
            my_size += ::protobuf::rt::value_varint_zigzag_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_sint64(1, v)?;
        }
        if !self.keys.is_empty() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.keys))?;
            for v in &self.keys {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if !self.vals.is_empty() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.vals))?;
            for v in &self.vals {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.lat {
            os.write_sint64(8, v)?;
        }
        if let Some(v) = self.lon {
            os.write_sint64(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Node {
        Node::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "id",
                |m: &Node| { &m.id },
                |m: &mut Node| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "keys",
                |m: &Node| { &m.keys },
                |m: &mut Node| { &mut m.keys },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "vals",
                |m: &Node| { &m.vals },
                |m: &mut Node| { &mut m.vals },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Info>>(
                "info",
                |m: &Node| { &m.info },
                |m: &mut Node| { &mut m.info },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "lat",
                |m: &Node| { &m.lat },
                |m: &mut Node| { &mut m.lat },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "lon",
                |m: &Node| { &m.lon },
                |m: &mut Node| { &mut m.lon },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Node>(
                "Node",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Node {
        static instance: ::protobuf::rt::LazyV2<Node> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Node::new)
    }
}

impl ::protobuf::Clear for Node {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.keys.clear();
        self.vals.clear();
        self.info.clear();
        self.lat = ::std::option::Option::None;
        self.lon = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Node {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Node {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DenseNodes {
    // message fields
    pub id: ::std::vec::Vec<i64>,
    pub denseinfo: ::protobuf::SingularPtrField<DenseInfo>,
    pub lat: ::std::vec::Vec<i64>,
    pub lon: ::std::vec::Vec<i64>,
    pub keys_vals: ::std::vec::Vec<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DenseNodes {
    fn default() -> &'a DenseNodes {
        <DenseNodes as ::protobuf::Message>::default_instance()
    }
}

impl DenseNodes {
    pub fn new() -> DenseNodes {
        ::std::default::Default::default()
    }

    // repeated sint64 id = 1;


    pub fn get_id(&self) -> &[i64] {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<i64>) {
        self.id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_id(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.id, ::std::vec::Vec::new())
    }

    // optional .OSMPBF.DenseInfo denseinfo = 5;


    pub fn get_denseinfo(&self) -> &DenseInfo {
        self.denseinfo.as_ref().unwrap_or_else(|| <DenseInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_denseinfo(&mut self) {
        self.denseinfo.clear();
    }

    pub fn has_denseinfo(&self) -> bool {
        self.denseinfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_denseinfo(&mut self, v: DenseInfo) {
        self.denseinfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_denseinfo(&mut self) -> &mut DenseInfo {
        if self.denseinfo.is_none() {
            self.denseinfo.set_default();
        }
        self.denseinfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_denseinfo(&mut self) -> DenseInfo {
        self.denseinfo.take().unwrap_or_else(|| DenseInfo::new())
    }

    // repeated sint64 lat = 8;


    pub fn get_lat(&self) -> &[i64] {
        &self.lat
    }
    pub fn clear_lat(&mut self) {
        self.lat.clear();
    }

    // Param is passed by value, moved
    pub fn set_lat(&mut self, v: ::std::vec::Vec<i64>) {
        self.lat = v;
    }

    // Mutable pointer to the field.
    pub fn mut_lat(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.lat
    }

    // Take field
    pub fn take_lat(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.lat, ::std::vec::Vec::new())
    }

    // repeated sint64 lon = 9;


    pub fn get_lon(&self) -> &[i64] {
        &self.lon
    }
    pub fn clear_lon(&mut self) {
        self.lon.clear();
    }

    // Param is passed by value, moved
    pub fn set_lon(&mut self, v: ::std::vec::Vec<i64>) {
        self.lon = v;
    }

    // Mutable pointer to the field.
    pub fn mut_lon(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.lon
    }

    // Take field
    pub fn take_lon(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.lon, ::std::vec::Vec::new())
    }

    // repeated int32 keys_vals = 10;


    pub fn get_keys_vals(&self) -> &[i32] {
        &self.keys_vals
    }
    pub fn clear_keys_vals(&mut self) {
        self.keys_vals.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys_vals(&mut self, v: ::std::vec::Vec<i32>) {
        self.keys_vals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys_vals(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.keys_vals
    }

    // Take field
    pub fn take_keys_vals(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.keys_vals, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DenseNodes {
    fn is_initialized(&self) -> bool {
        for v in &self.denseinfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_sint64_into(wire_type, is, &mut self.id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.denseinfo)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_sint64_into(wire_type, is, &mut self.lat)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_sint64_into(wire_type, is, &mut self.lon)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.keys_vals)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_zigzag_size(1, &self.id);
        }
        if let Some(ref v) = self.denseinfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.lat.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_zigzag_size(8, &self.lat);
        }
        if !self.lon.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_zigzag_size(9, &self.lon);
        }
        if !self.keys_vals.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(10, &self.keys_vals);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_zigzag_data_size(&self.id))?;
            for v in &self.id {
                os.write_sint64_no_tag(*v)?;
            };
        }
        if let Some(ref v) = self.denseinfo.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.lat.is_empty() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_zigzag_data_size(&self.lat))?;
            for v in &self.lat {
                os.write_sint64_no_tag(*v)?;
            };
        }
        if !self.lon.is_empty() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_zigzag_data_size(&self.lon))?;
            for v in &self.lon {
                os.write_sint64_no_tag(*v)?;
            };
        }
        if !self.keys_vals.is_empty() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.keys_vals))?;
            for v in &self.keys_vals {
                os.write_int32_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DenseNodes {
        DenseNodes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "id",
                |m: &DenseNodes| { &m.id },
                |m: &mut DenseNodes| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DenseInfo>>(
                "denseinfo",
                |m: &DenseNodes| { &m.denseinfo },
                |m: &mut DenseNodes| { &mut m.denseinfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "lat",
                |m: &DenseNodes| { &m.lat },
                |m: &mut DenseNodes| { &mut m.lat },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "lon",
                |m: &DenseNodes| { &m.lon },
                |m: &mut DenseNodes| { &mut m.lon },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "keys_vals",
                |m: &DenseNodes| { &m.keys_vals },
                |m: &mut DenseNodes| { &mut m.keys_vals },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DenseNodes>(
                "DenseNodes",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DenseNodes {
        static instance: ::protobuf::rt::LazyV2<DenseNodes> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DenseNodes::new)
    }
}

impl ::protobuf::Clear for DenseNodes {
    fn clear(&mut self) {
        self.id.clear();
        self.denseinfo.clear();
        self.lat.clear();
        self.lon.clear();
        self.keys_vals.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DenseNodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DenseNodes {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Way {
    // message fields
    id: ::std::option::Option<i64>,
    pub keys: ::std::vec::Vec<u32>,
    pub vals: ::std::vec::Vec<u32>,
    pub info: ::protobuf::SingularPtrField<Info>,
    pub refs: ::std::vec::Vec<i64>,
    pub lat: ::std::vec::Vec<i64>,
    pub lon: ::std::vec::Vec<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Way {
    fn default() -> &'a Way {
        <Way as ::protobuf::Message>::default_instance()
    }
}

impl Way {
    pub fn new() -> Way {
        ::std::default::Default::default()
    }

    // required int64 id = 1;


    pub fn get_id(&self) -> i64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }

    // repeated uint32 keys = 2;


    pub fn get_keys(&self) -> &[u32] {
        &self.keys
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::std::vec::Vec<u32>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.keys
    }

    // Take field
    pub fn take_keys(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.keys, ::std::vec::Vec::new())
    }

    // repeated uint32 vals = 3;


    pub fn get_vals(&self) -> &[u32] {
        &self.vals
    }
    pub fn clear_vals(&mut self) {
        self.vals.clear();
    }

    // Param is passed by value, moved
    pub fn set_vals(&mut self, v: ::std::vec::Vec<u32>) {
        self.vals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vals(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.vals
    }

    // Take field
    pub fn take_vals(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.vals, ::std::vec::Vec::new())
    }

    // optional .OSMPBF.Info info = 4;


    pub fn get_info(&self) -> &Info {
        self.info.as_ref().unwrap_or_else(|| <Info as ::protobuf::Message>::default_instance())
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: Info) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut Info {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> Info {
        self.info.take().unwrap_or_else(|| Info::new())
    }

    // repeated sint64 refs = 8;


    pub fn get_refs(&self) -> &[i64] {
        &self.refs
    }
    pub fn clear_refs(&mut self) {
        self.refs.clear();
    }

    // Param is passed by value, moved
    pub fn set_refs(&mut self, v: ::std::vec::Vec<i64>) {
        self.refs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_refs(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.refs
    }

    // Take field
    pub fn take_refs(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.refs, ::std::vec::Vec::new())
    }

    // repeated sint64 lat = 9;


    pub fn get_lat(&self) -> &[i64] {
        &self.lat
    }
    pub fn clear_lat(&mut self) {
        self.lat.clear();
    }

    // Param is passed by value, moved
    pub fn set_lat(&mut self, v: ::std::vec::Vec<i64>) {
        self.lat = v;
    }

    // Mutable pointer to the field.
    pub fn mut_lat(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.lat
    }

    // Take field
    pub fn take_lat(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.lat, ::std::vec::Vec::new())
    }

    // repeated sint64 lon = 10;


    pub fn get_lon(&self) -> &[i64] {
        &self.lon
    }
    pub fn clear_lon(&mut self) {
        self.lon.clear();
    }

    // Param is passed by value, moved
    pub fn set_lon(&mut self, v: ::std::vec::Vec<i64>) {
        self.lon = v;
    }

    // Mutable pointer to the field.
    pub fn mut_lon(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.lon
    }

    // Take field
    pub fn take_lon(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.lon, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Way {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.keys)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.vals)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_sint64_into(wire_type, is, &mut self.refs)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_sint64_into(wire_type, is, &mut self.lat)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_sint64_into(wire_type, is, &mut self.lon)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.keys.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(2, &self.keys);
        }
        if !self.vals.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(3, &self.vals);
        }
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.refs.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_zigzag_size(8, &self.refs);
        }
        if !self.lat.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_zigzag_size(9, &self.lat);
        }
        if !self.lon.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_zigzag_size(10, &self.lon);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_int64(1, v)?;
        }
        if !self.keys.is_empty() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.keys))?;
            for v in &self.keys {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if !self.vals.is_empty() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.vals))?;
            for v in &self.vals {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.refs.is_empty() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_zigzag_data_size(&self.refs))?;
            for v in &self.refs {
                os.write_sint64_no_tag(*v)?;
            };
        }
        if !self.lat.is_empty() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_zigzag_data_size(&self.lat))?;
            for v in &self.lat {
                os.write_sint64_no_tag(*v)?;
            };
        }
        if !self.lon.is_empty() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_zigzag_data_size(&self.lon))?;
            for v in &self.lon {
                os.write_sint64_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Way {
        Way::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "id",
                |m: &Way| { &m.id },
                |m: &mut Way| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "keys",
                |m: &Way| { &m.keys },
                |m: &mut Way| { &mut m.keys },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "vals",
                |m: &Way| { &m.vals },
                |m: &mut Way| { &mut m.vals },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Info>>(
                "info",
                |m: &Way| { &m.info },
                |m: &mut Way| { &mut m.info },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "refs",
                |m: &Way| { &m.refs },
                |m: &mut Way| { &mut m.refs },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "lat",
                |m: &Way| { &m.lat },
                |m: &mut Way| { &mut m.lat },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "lon",
                |m: &Way| { &m.lon },
                |m: &mut Way| { &mut m.lon },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Way>(
                "Way",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Way {
        static instance: ::protobuf::rt::LazyV2<Way> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Way::new)
    }
}

impl ::protobuf::Clear for Way {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.keys.clear();
        self.vals.clear();
        self.info.clear();
        self.refs.clear();
        self.lat.clear();
        self.lon.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Way {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Way {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Relation {
    // message fields
    id: ::std::option::Option<i64>,
    pub keys: ::std::vec::Vec<u32>,
    pub vals: ::std::vec::Vec<u32>,
    pub info: ::protobuf::SingularPtrField<Info>,
    pub roles_sid: ::std::vec::Vec<i32>,
    pub memids: ::std::vec::Vec<i64>,
    pub types: ::std::vec::Vec<Relation_MemberType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Relation {
    fn default() -> &'a Relation {
        <Relation as ::protobuf::Message>::default_instance()
    }
}

impl Relation {
    pub fn new() -> Relation {
        ::std::default::Default::default()
    }

    // required int64 id = 1;


    pub fn get_id(&self) -> i64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }

    // repeated uint32 keys = 2;


    pub fn get_keys(&self) -> &[u32] {
        &self.keys
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::std::vec::Vec<u32>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.keys
    }

    // Take field
    pub fn take_keys(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.keys, ::std::vec::Vec::new())
    }

    // repeated uint32 vals = 3;


    pub fn get_vals(&self) -> &[u32] {
        &self.vals
    }
    pub fn clear_vals(&mut self) {
        self.vals.clear();
    }

    // Param is passed by value, moved
    pub fn set_vals(&mut self, v: ::std::vec::Vec<u32>) {
        self.vals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vals(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.vals
    }

    // Take field
    pub fn take_vals(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.vals, ::std::vec::Vec::new())
    }

    // optional .OSMPBF.Info info = 4;


    pub fn get_info(&self) -> &Info {
        self.info.as_ref().unwrap_or_else(|| <Info as ::protobuf::Message>::default_instance())
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: Info) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut Info {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> Info {
        self.info.take().unwrap_or_else(|| Info::new())
    }

    // repeated int32 roles_sid = 8;


    pub fn get_roles_sid(&self) -> &[i32] {
        &self.roles_sid
    }
    pub fn clear_roles_sid(&mut self) {
        self.roles_sid.clear();
    }

    // Param is passed by value, moved
    pub fn set_roles_sid(&mut self, v: ::std::vec::Vec<i32>) {
        self.roles_sid = v;
    }

    // Mutable pointer to the field.
    pub fn mut_roles_sid(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.roles_sid
    }

    // Take field
    pub fn take_roles_sid(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.roles_sid, ::std::vec::Vec::new())
    }

    // repeated sint64 memids = 9;


    pub fn get_memids(&self) -> &[i64] {
        &self.memids
    }
    pub fn clear_memids(&mut self) {
        self.memids.clear();
    }

    // Param is passed by value, moved
    pub fn set_memids(&mut self, v: ::std::vec::Vec<i64>) {
        self.memids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_memids(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.memids
    }

    // Take field
    pub fn take_memids(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.memids, ::std::vec::Vec::new())
    }

    // repeated .OSMPBF.Relation.MemberType types = 10;


    pub fn get_types(&self) -> &[Relation_MemberType] {
        &self.types
    }
    pub fn clear_types(&mut self) {
        self.types.clear();
    }

    // Param is passed by value, moved
    pub fn set_types(&mut self, v: ::std::vec::Vec<Relation_MemberType>) {
        self.types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_types(&mut self) -> &mut ::std::vec::Vec<Relation_MemberType> {
        &mut self.types
    }

    // Take field
    pub fn take_types(&mut self) -> ::std::vec::Vec<Relation_MemberType> {
        ::std::mem::replace(&mut self.types, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Relation {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.keys)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.vals)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.roles_sid)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_sint64_into(wire_type, is, &mut self.memids)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.types, 10, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.keys.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(2, &self.keys);
        }
        if !self.vals.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(3, &self.vals);
        }
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.roles_sid.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(8, &self.roles_sid);
        }
        if !self.memids.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_zigzag_size(9, &self.memids);
        }
        if !self.types.is_empty() {
            my_size += ::protobuf::rt::vec_packed_enum_size(10, &self.types);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_int64(1, v)?;
        }
        if !self.keys.is_empty() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.keys))?;
            for v in &self.keys {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if !self.vals.is_empty() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.vals))?;
            for v in &self.vals {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.roles_sid.is_empty() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.roles_sid))?;
            for v in &self.roles_sid {
                os.write_int32_no_tag(*v)?;
            };
        }
        if !self.memids.is_empty() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_zigzag_data_size(&self.memids))?;
            for v in &self.memids {
                os.write_sint64_no_tag(*v)?;
            };
        }
        if !self.types.is_empty() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_enum_data_size(&self.types))?;
            for v in &self.types {
                os.write_enum_no_tag(::protobuf::ProtobufEnum::value(v))?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Relation {
        Relation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "id",
                |m: &Relation| { &m.id },
                |m: &mut Relation| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "keys",
                |m: &Relation| { &m.keys },
                |m: &mut Relation| { &mut m.keys },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "vals",
                |m: &Relation| { &m.vals },
                |m: &mut Relation| { &mut m.vals },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Info>>(
                "info",
                |m: &Relation| { &m.info },
                |m: &mut Relation| { &mut m.info },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "roles_sid",
                |m: &Relation| { &m.roles_sid },
                |m: &mut Relation| { &mut m.roles_sid },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "memids",
                |m: &Relation| { &m.memids },
                |m: &mut Relation| { &mut m.memids },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Relation_MemberType>>(
                "types",
                |m: &Relation| { &m.types },
                |m: &mut Relation| { &mut m.types },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Relation>(
                "Relation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Relation {
        static instance: ::protobuf::rt::LazyV2<Relation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Relation::new)
    }
}

impl ::protobuf::Clear for Relation {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.keys.clear();
        self.vals.clear();
        self.info.clear();
        self.roles_sid.clear();
        self.memids.clear();
        self.types.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Relation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Relation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Relation_MemberType {
    NODE = 0,
    WAY = 1,
    RELATION = 2,
}

impl ::protobuf::ProtobufEnum for Relation_MemberType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Relation_MemberType> {
        match value {
            0 => ::std::option::Option::Some(Relation_MemberType::NODE),
            1 => ::std::option::Option::Some(Relation_MemberType::WAY),
            2 => ::std::option::Option::Some(Relation_MemberType::RELATION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Relation_MemberType] = &[
            Relation_MemberType::NODE,
            Relation_MemberType::WAY,
            Relation_MemberType::RELATION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Relation_MemberType>("Relation.MemberType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Relation_MemberType {
}

impl ::std::default::Default for Relation_MemberType {
    fn default() -> Self {
        Relation_MemberType::NODE
    }
}

impl ::protobuf::reflect::ProtobufValue for Relation_MemberType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x19src/proto/osmformat.proto\x12\x06OSMPBF\"\xa3\x03\n\x0bHeaderBlock\
    \x12&\n\x04bbox\x18\x01\x20\x01(\x0b2\x12.OSMPBF.HeaderBBoxR\x04bbox\x12\
    +\n\x11required_features\x18\x04\x20\x03(\tR\x10requiredFeatures\x12+\n\
    \x11optional_features\x18\x05\x20\x03(\tR\x10optionalFeatures\x12&\n\x0e\
    writingprogram\x18\x10\x20\x01(\tR\x0ewritingprogram\x12\x16\n\x06source\
    \x18\x11\x20\x01(\tR\x06source\x12B\n\x1dosmosis_replication_timestamp\
    \x18\x20\x20\x01(\x03R\x1bosmosisReplicationTimestamp\x12M\n#osmosis_rep\
    lication_sequence_number\x18!\x20\x01(\x03R\x20osmosisReplicationSequenc\
    eNumber\x12?\n\x1cosmosis_replication_base_url\x18\"\x20\x01(\tR\x19osmo\
    sisReplicationBaseUrl\"`\n\nHeaderBBox\x12\x12\n\x04left\x18\x01\x20\x02\
    (\x12R\x04left\x12\x14\n\x05right\x18\x02\x20\x02(\x12R\x05right\x12\x10\
    \n\x03top\x18\x03\x20\x02(\x12R\x03top\x12\x16\n\x06bottom\x18\x04\x20\
    \x02(\x12R\x06bottom\"\xa3\x02\n\x0ePrimitiveBlock\x125\n\x0bstringtable\
    \x18\x01\x20\x02(\x0b2\x13.OSMPBF.StringTableR\x0bstringtable\x12>\n\x0e\
    primitivegroup\x18\x02\x20\x03(\x0b2\x16.OSMPBF.PrimitiveGroupR\x0eprimi\
    tivegroup\x12%\n\x0bgranularity\x18\x11\x20\x01(\x05:\x03100R\x0bgranula\
    rity\x12\x20\n\nlat_offset\x18\x13\x20\x01(\x03:\x010R\tlatOffset\x12\
    \x20\n\nlon_offset\x18\x14\x20\x01(\x03:\x010R\tlonOffset\x12/\n\x10date\
    _granularity\x18\x12\x20\x01(\x05:\x041000R\x0fdateGranularity\"\xe2\x01\
    \n\x0ePrimitiveGroup\x12\"\n\x05nodes\x18\x01\x20\x03(\x0b2\x0c.OSMPBF.N\
    odeR\x05nodes\x12(\n\x05dense\x18\x02\x20\x01(\x0b2\x12.OSMPBF.DenseNode\
    sR\x05dense\x12\x1f\n\x04ways\x18\x03\x20\x03(\x0b2\x0b.OSMPBF.WayR\x04w\
    ays\x12.\n\trelations\x18\x04\x20\x03(\x0b2\x10.OSMPBF.RelationR\trelati\
    ons\x121\n\nchangesets\x18\x05\x20\x03(\x0b2\x11.OSMPBF.ChangeSetR\nchan\
    gesets\"\x1b\n\x0bStringTable\x12\x0c\n\x01s\x18\x01\x20\x03(\x0cR\x01s\
    \"\xa7\x01\n\x04Info\x12\x1c\n\x07version\x18\x01\x20\x01(\x05:\x02-1R\
    \x07version\x12\x1c\n\ttimestamp\x18\x02\x20\x01(\x03R\ttimestamp\x12\
    \x1c\n\tchangeset\x18\x03\x20\x01(\x03R\tchangeset\x12\x10\n\x03uid\x18\
    \x04\x20\x01(\x05R\x03uid\x12\x19\n\x08user_sid\x18\x05\x20\x01(\rR\x07u\
    serSid\x12\x18\n\x07visible\x18\x06\x20\x01(\x08R\x07visible\"\xc0\x01\n\
    \tDenseInfo\x12\x1c\n\x07version\x18\x01\x20\x03(\x05R\x07versionB\x02\
    \x10\x01\x12\x20\n\ttimestamp\x18\x02\x20\x03(\x12R\ttimestampB\x02\x10\
    \x01\x12\x20\n\tchangeset\x18\x03\x20\x03(\x12R\tchangesetB\x02\x10\x01\
    \x12\x14\n\x03uid\x18\x04\x20\x03(\x11R\x03uidB\x02\x10\x01\x12\x1d\n\
    \x08user_sid\x18\x05\x20\x03(\x11R\x07userSidB\x02\x10\x01\x12\x1c\n\x07\
    visible\x18\x06\x20\x03(\x08R\x07visibleB\x02\x10\x01\"\x1b\n\tChangeSet\
    \x12\x0e\n\x02id\x18\x01\x20\x02(\x03R\x02id\"\x8c\x01\n\x04Node\x12\x0e\
    \n\x02id\x18\x01\x20\x02(\x12R\x02id\x12\x16\n\x04keys\x18\x02\x20\x03(\
    \rR\x04keysB\x02\x10\x01\x12\x16\n\x04vals\x18\x03\x20\x03(\rR\x04valsB\
    \x02\x10\x01\x12\x20\n\x04info\x18\x04\x20\x01(\x0b2\x0c.OSMPBF.InfoR\
    \x04info\x12\x10\n\x03lat\x18\x08\x20\x02(\x12R\x03lat\x12\x10\n\x03lon\
    \x18\t\x20\x02(\x12R\x03lon\"\x9e\x01\n\nDenseNodes\x12\x12\n\x02id\x18\
    \x01\x20\x03(\x12R\x02idB\x02\x10\x01\x12/\n\tdenseinfo\x18\x05\x20\x01(\
    \x0b2\x11.OSMPBF.DenseInfoR\tdenseinfo\x12\x14\n\x03lat\x18\x08\x20\x03(\
    \x12R\x03latB\x02\x10\x01\x12\x14\n\x03lon\x18\t\x20\x03(\x12R\x03lonB\
    \x02\x10\x01\x12\x1f\n\tkeys_vals\x18\n\x20\x03(\x05R\x08keysValsB\x02\
    \x10\x01\"\xab\x01\n\x03Way\x12\x0e\n\x02id\x18\x01\x20\x02(\x03R\x02id\
    \x12\x16\n\x04keys\x18\x02\x20\x03(\rR\x04keysB\x02\x10\x01\x12\x16\n\
    \x04vals\x18\x03\x20\x03(\rR\x04valsB\x02\x10\x01\x12\x20\n\x04info\x18\
    \x04\x20\x01(\x0b2\x0c.OSMPBF.InfoR\x04info\x12\x16\n\x04refs\x18\x08\
    \x20\x03(\x12R\x04refsB\x02\x10\x01\x12\x14\n\x03lat\x18\t\x20\x03(\x12R\
    \x03latB\x02\x10\x01\x12\x14\n\x03lon\x18\n\x20\x03(\x12R\x03lonB\x02\
    \x10\x01\"\x8f\x02\n\x08Relation\x12\x0e\n\x02id\x18\x01\x20\x02(\x03R\
    \x02id\x12\x16\n\x04keys\x18\x02\x20\x03(\rR\x04keysB\x02\x10\x01\x12\
    \x16\n\x04vals\x18\x03\x20\x03(\rR\x04valsB\x02\x10\x01\x12\x20\n\x04inf\
    o\x18\x04\x20\x01(\x0b2\x0c.OSMPBF.InfoR\x04info\x12\x1f\n\troles_sid\
    \x18\x08\x20\x03(\x05R\x08rolesSidB\x02\x10\x01\x12\x1a\n\x06memids\x18\
    \t\x20\x03(\x12R\x06memidsB\x02\x10\x01\x125\n\x05types\x18\n\x20\x03(\
    \x0e2\x1b.OSMPBF.Relation.MemberTypeR\x05typesB\x02\x10\x01\"-\n\nMember\
    Type\x12\x08\n\x04NODE\x10\0\x12\x07\n\x03WAY\x10\x01\x12\x0c\n\x08RELAT\
    ION\x10\x02B\x0f\n\rcrosby.binary\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
